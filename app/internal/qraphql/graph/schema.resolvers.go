package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"strings"

	"github.com/RoGogDBD/GQLGo/internal/models"
	"github.com/RoGogDBD/GQLGo/internal/utils/graph"
)

// Children is the resolver for the children field.
func (r *commentResolver) Children(ctx context.Context, obj *models.Comment, first *int32, after *string, order *models.CommentOrder) (*models.CommentConnection, error) {
	parentID := obj.ID
	return graph.ResolveCommentConnection(ctx, r.CommentRepo, obj.PostID, &parentID, first, after, order, models.CommentOrderOldest)
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input models.CreatePostInput) (*models.Post, error) {
	return r.PostRepo.Create(ctx, input)
}

// SetCommentsEnabled is the resolver for the setCommentsEnabled field.
func (r *mutationResolver) SetCommentsEnabled(ctx context.Context, postID string, enabled bool) (*models.Post, error) {
	return r.PostRepo.SetCommentsEnabled(ctx, postID, enabled)
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, input models.AddCommentInput) (*models.Comment, error) {
	if input.PostID == "" {
		return nil, fmt.Errorf("требуется id поста")
	}
	if input.AuthorID == "" {
		return nil, fmt.Errorf("требуется id автора")
	}

	body := strings.TrimSpace(input.Body)
	if body == "" {
		return nil, fmt.Errorf("требуется тело коммента")
	}
	if len(body) > 2000 {
		return nil, fmt.Errorf("тело комментария длинное (<= 2000)")
	}

	post, err := r.PostRepo.GetByID(ctx, input.PostID)
	if err != nil {
		return nil, err
	}
	if post == nil {
		return nil, fmt.Errorf("пост не найден")
	}
	if !post.CommentsEnabled {
		return nil, fmt.Errorf("комментарии отключены")
	}

	depth, err := graph.ResolveCommentDepth(ctx, r.CommentRepo, input.PostID, input.ParentID)
	if err != nil {
		return nil, err
	}

	comment, err := r.CommentRepo.Create(ctx, input.PostID, input.AuthorID, input.ParentID, body, depth)
	if err != nil {
		return nil, err
	}
	if r.CommentNotifier != nil {
		r.CommentNotifier.Publish(input.PostID, comment)
	}
	return comment, nil
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *models.Post, first *int32, after *string, order *models.CommentOrder) (*models.CommentConnection, error) {
	return graph.ResolveCommentConnection(ctx, r.CommentRepo, obj.ID, nil, first, after, order, models.CommentOrderNewest)
}

// GetPosts is the resolver for the GetPosts field.
func (r *queryResolver) GetPosts(ctx context.Context, first *int32, after *string) (*models.PostConnection, error) {
	f := int32(20)
	if first != nil {
		f = *first
	}
	list, endCursor, err := r.PostRepo.List(ctx, f, after)
	if err != nil {
		return nil, err
	}
	return graph.NewPostConnection(list, endCursor), nil
}

// GetPost is the resolver for the GetPost field.
func (r *queryResolver) GetPost(ctx context.Context, id string) (*models.Post, error) {
	return r.PostRepo.GetByID(ctx, id)
}

// GetUsers is the resolver for the GetUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, first *int32, after *string) (*models.UserConnection, error) {
	f := int32(20)
	if first != nil {
		f = *first
	}
	list, endCursor, err := r.UserRepo.List(ctx, f, after)
	if err != nil {
		return nil, err
	}
	return graph.NewUserConnection(list, endCursor), nil
}

// GetUser is the resolver for the GetUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*models.User, error) {
	return r.UserRepo.GetByID(ctx, id)
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *models.Comment, error) {
	if postID == "" {
		return nil, fmt.Errorf("требуется id поста")
	}
	if r.CommentNotifier == nil {
		return nil, fmt.Errorf("subscriptions отключены")
	}

	ch, unsubscribe := r.CommentNotifier.Subscribe(postID)

	go func() {
		<-ctx.Done()
		unsubscribe()
	}()

	return ch, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
